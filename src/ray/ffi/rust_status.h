// Copyright 2017 The Ray Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <memory>
#include <string>

#include "rust/cxx.h"

// Include the generated CXX bridge header
// This is generated by cxxbridge from status.rs
#include "src/ray/ffi/status_bridge_gen.h"

namespace ray {

/// Drop-in replacement for ray::Status backed by Rust implementation.
///
/// This class provides a C++ interface that mirrors the original ray::Status
/// class, but uses the Rust implementation under the hood. This enables
/// functional equivalence testing between C++ and Rust implementations.
class RustStatus {
 public:
  /// Create a success status.
  RustStatus() : impl_(ffi::status_ok()) {}

  /// Copy constructor.
  RustStatus(const RustStatus &other) : impl_(ffi::status_clone(*other.impl_)) {}

  /// Copy assignment.
  RustStatus &operator=(const RustStatus &other) {
    if (this != &other) {
      impl_ = ffi::status_clone(*other.impl_);
    }
    return *this;
  }

  /// Move constructor.
  RustStatus(RustStatus &&other) noexcept = default;

  /// Move assignment.
  RustStatus &operator=(RustStatus &&other) noexcept = default;

  /// Destructor.
  ~RustStatus() = default;

  /// Return a success status.
  static RustStatus OK() { return RustStatus(); }

  /// Return error status of an appropriate type.
  static RustStatus OutOfMemory(const std::string &msg) {
    return RustStatus(ffi::StatusCode::OutOfMemory, msg);
  }

  static RustStatus KeyError(const std::string &msg) {
    return RustStatus(ffi::StatusCode::KeyError, msg);
  }

  static RustStatus TypeError(const std::string &msg) {
    return RustStatus(ffi::StatusCode::TypeError, msg);
  }

  static RustStatus Invalid(const std::string &msg) {
    return RustStatus(ffi::StatusCode::Invalid, msg);
  }

  static RustStatus IOError(const std::string &msg) {
    return RustStatus(ffi::StatusCode::IOError, msg);
  }

  static RustStatus UnknownError(const std::string &msg) {
    return RustStatus(ffi::StatusCode::UnknownError, msg);
  }

  static RustStatus NotImplemented(const std::string &msg) {
    return RustStatus(ffi::StatusCode::NotImplemented, msg);
  }

  static RustStatus RedisError(const std::string &msg) {
    return RustStatus(ffi::StatusCode::RedisError, msg);
  }

  static RustStatus TimedOut(const std::string &msg) {
    return RustStatus(ffi::StatusCode::TimedOut, msg);
  }

  static RustStatus Interrupted(const std::string &msg) {
    return RustStatus(ffi::StatusCode::Interrupted, msg);
  }

  static RustStatus IntentionalSystemExit(const std::string &msg) {
    return RustStatus(ffi::StatusCode::IntentionalSystemExit, msg);
  }

  static RustStatus UnexpectedSystemExit(const std::string &msg) {
    return RustStatus(ffi::StatusCode::UnexpectedSystemExit, msg);
  }

  static RustStatus CreationTaskError(const std::string &msg) {
    return RustStatus(ffi::StatusCode::CreationTaskError, msg);
  }

  static RustStatus NotFound(const std::string &msg) {
    return RustStatus(ffi::StatusCode::NotFound, msg);
  }

  static RustStatus Disconnected(const std::string &msg) {
    return RustStatus(ffi::StatusCode::Disconnected, msg);
  }

  static RustStatus SchedulingCancelled(const std::string &msg) {
    return RustStatus(ffi::StatusCode::SchedulingCancelled, msg);
  }

  static RustStatus AlreadyExists(const std::string &msg) {
    return RustStatus(ffi::StatusCode::AlreadyExists, msg);
  }

  static RustStatus ObjectExists(const std::string &msg) {
    return RustStatus(ffi::StatusCode::ObjectExists, msg);
  }

  static RustStatus ObjectNotFound(const std::string &msg) {
    return RustStatus(ffi::StatusCode::ObjectNotFound, msg);
  }

  static RustStatus ObjectUnknownOwner(const std::string &msg) {
    return RustStatus(ffi::StatusCode::ObjectUnknownOwner, msg);
  }

  static RustStatus ObjectAlreadySealed(const std::string &msg) {
    return RustStatus(ffi::StatusCode::ObjectAlreadySealed, msg);
  }

  static RustStatus ObjectStoreFull(const std::string &msg) {
    return RustStatus(ffi::StatusCode::ObjectStoreFull, msg);
  }

  static RustStatus TransientObjectStoreFull(const std::string &msg) {
    return RustStatus(ffi::StatusCode::TransientObjectStoreFull, msg);
  }

  static RustStatus OutOfDisk(const std::string &msg) {
    return RustStatus(ffi::StatusCode::OutOfDisk, msg);
  }

  static RustStatus RpcError(const std::string &msg, int rpc_code) {
    RustStatus status;
    status.impl_ = ffi::status_rpc_error(msg, rpc_code);
    return status;
  }

  static RustStatus OutOfResource(const std::string &msg) {
    return RustStatus(ffi::StatusCode::OutOfResource, msg);
  }

  static RustStatus ObjectRefEndOfStream(const std::string &msg) {
    return RustStatus(ffi::StatusCode::ObjectRefEndOfStream, msg);
  }

  static RustStatus Unauthenticated(const std::string &msg) {
    return RustStatus(ffi::StatusCode::Unauthenticated, msg);
  }

  static RustStatus InvalidArgument(const std::string &msg) {
    return RustStatus(ffi::StatusCode::InvalidArgument, msg);
  }

  static RustStatus ChannelError(const std::string &msg) {
    return RustStatus(ffi::StatusCode::ChannelError, msg);
  }

  static RustStatus ChannelTimeoutError(const std::string &msg) {
    return RustStatus(ffi::StatusCode::ChannelTimeoutError, msg);
  }

  static RustStatus PermissionDenied(const std::string &msg) {
    return RustStatus(ffi::StatusCode::PermissionDenied, msg);
  }

  /// Returns true iff the status indicates success.
  bool ok() const { return ffi::status_is_ok(*impl_); }

  /// Status check methods.
  bool IsOutOfMemory() const { return code() == ffi::StatusCode::OutOfMemory; }
  bool IsKeyError() const { return code() == ffi::StatusCode::KeyError; }
  bool IsTypeError() const { return code() == ffi::StatusCode::TypeError; }
  bool IsInvalid() const { return code() == ffi::StatusCode::Invalid; }
  bool IsIOError() const { return code() == ffi::StatusCode::IOError; }
  bool IsUnknownError() const { return code() == ffi::StatusCode::UnknownError; }
  bool IsNotImplemented() const { return code() == ffi::StatusCode::NotImplemented; }
  bool IsRedisError() const { return code() == ffi::StatusCode::RedisError; }
  bool IsTimedOut() const { return code() == ffi::StatusCode::TimedOut; }
  bool IsInterrupted() const { return code() == ffi::StatusCode::Interrupted; }
  bool IsIntentionalSystemExit() const {
    return code() == ffi::StatusCode::IntentionalSystemExit;
  }
  bool IsUnexpectedSystemExit() const {
    return code() == ffi::StatusCode::UnexpectedSystemExit;
  }
  bool IsCreationTaskError() const { return code() == ffi::StatusCode::CreationTaskError; }
  bool IsNotFound() const { return code() == ffi::StatusCode::NotFound; }
  bool IsDisconnected() const { return code() == ffi::StatusCode::Disconnected; }
  bool IsSchedulingCancelled() const {
    return code() == ffi::StatusCode::SchedulingCancelled;
  }
  bool IsAlreadyExists() const { return code() == ffi::StatusCode::AlreadyExists; }
  bool IsObjectExists() const { return code() == ffi::StatusCode::ObjectExists; }
  bool IsObjectNotFound() const { return code() == ffi::StatusCode::ObjectNotFound; }
  bool IsObjectUnknownOwner() const { return code() == ffi::StatusCode::ObjectUnknownOwner; }
  bool IsObjectAlreadySealed() const {
    return code() == ffi::StatusCode::ObjectAlreadySealed;
  }
  bool IsObjectStoreFull() const { return code() == ffi::StatusCode::ObjectStoreFull; }
  bool IsTransientObjectStoreFull() const {
    return code() == ffi::StatusCode::TransientObjectStoreFull;
  }
  bool IsOutOfDisk() const { return code() == ffi::StatusCode::OutOfDisk; }
  bool IsRpcError() const { return code() == ffi::StatusCode::RpcError; }
  bool IsOutOfResource() const { return code() == ffi::StatusCode::OutOfResource; }
  bool IsObjectRefEndOfStream() const {
    return code() == ffi::StatusCode::ObjectRefEndOfStream;
  }
  bool IsUnauthenticated() const { return code() == ffi::StatusCode::Unauthenticated; }
  bool IsInvalidArgument() const { return code() == ffi::StatusCode::InvalidArgument; }
  bool IsChannelError() const { return code() == ffi::StatusCode::ChannelError; }
  bool IsChannelTimeoutError() const {
    return code() == ffi::StatusCode::ChannelTimeoutError;
  }
  bool IsPermissionDenied() const { return code() == ffi::StatusCode::PermissionDenied; }

  /// Return a string representation of this status suitable for printing.
  std::string ToString() const {
    return std::string(ffi::status_to_string(*impl_));
  }

  /// Return the status code.
  ffi::StatusCode code() const { return ffi::status_code(*impl_); }

  /// Return the RPC error code (if applicable).
  int rpc_code() const { return ffi::status_rpc_code(*impl_); }

  /// Return the error message.
  std::string message() const {
    auto msg = ffi::status_message(*impl_);
    return std::string(msg.data(), msg.size());
  }

 private:
  RustStatus(ffi::StatusCode code, const std::string &msg)
      : impl_(ffi::status_error(code, msg)) {}

  rust::Box<ffi::RustStatus> impl_;
};

}  // namespace ray

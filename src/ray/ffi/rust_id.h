// Copyright 2017 The Ray Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <cstdint>
#include <memory>
#include <string>

#include "rust/cxx.h"

// Include the generated CXX bridge header
// This is generated by cxxbridge from id.rs
#include "src/ray/ffi/id_bridge_gen.h"

namespace ray {

/// ID sizes matching C++ implementation
constexpr size_t kRustJobIdSize = 4;
constexpr size_t kRustActorIdSize = 16;
constexpr size_t kRustTaskIdSize = 24;
constexpr size_t kRustObjectIdSize = 28;
constexpr size_t kRustUniqueIdSize = 28;
constexpr size_t kRustPlacementGroupIdSize = 18;
constexpr size_t kRustLeaseIdSize = 32;

// Forward declarations
class RustJobId;
class RustActorId;
class RustTaskId;
class RustObjectId;
class RustUniqueId;
class RustPlacementGroupId;
class RustLeaseId;

/// Drop-in replacement for ray::JobID backed by Rust implementation.
class RustJobId {
 public:
  static constexpr size_t Size() { return kRustJobIdSize; }

  RustJobId() : impl_(ffi::job_id_nil()) {}

  RustJobId(const RustJobId &other) : impl_(ffi::job_id_clone(*other.impl_)) {}

  RustJobId &operator=(const RustJobId &other) {
    if (this != &other) {
      impl_ = ffi::job_id_clone(*other.impl_);
    }
    return *this;
  }

  RustJobId(RustJobId &&other) noexcept = default;
  RustJobId &operator=(RustJobId &&other) noexcept = default;
  ~RustJobId() = default;

  static RustJobId FromInt(uint32_t value) {
    RustJobId id;
    id.impl_ = ffi::job_id_from_int(value);
    return id;
  }

  static RustJobId FromBinary(const std::string &binary) {
    RustJobId id;
    rust::Slice<const uint8_t> slice(
        reinterpret_cast<const uint8_t *>(binary.data()), binary.size());
    id.impl_ = ffi::job_id_from_binary(slice);
    return id;
  }

  static RustJobId FromHex(const std::string &hex) {
    RustJobId id;
    id.impl_ = ffi::job_id_from_hex(hex);
    return id;
  }

  static const RustJobId &Nil() {
    static RustJobId nil;
    return nil;
  }

  uint32_t ToInt() const { return ffi::job_id_to_int(*impl_); }

  std::string Binary() const {
    auto vec = ffi::job_id_to_binary(*impl_);
    return std::string(reinterpret_cast<const char *>(vec.data()), vec.size());
  }

  std::string Hex() const { return std::string(ffi::job_id_to_hex(*impl_)); }

  bool IsNil() const { return ffi::job_id_is_nil(*impl_); }

  size_t Hash() const { return ffi::job_id_hash(*impl_); }

  bool operator==(const RustJobId &other) const {
    return ffi::job_id_eq(*impl_, *other.impl_);
  }

  bool operator!=(const RustJobId &other) const { return !(*this == other); }

  const ffi::RustJobId &impl() const { return *impl_; }

 private:
  rust::Box<ffi::RustJobId> impl_;
};

/// Drop-in replacement for ray::ActorID backed by Rust implementation.
class RustActorId {
 public:
  static constexpr size_t Size() { return kRustActorIdSize; }

  RustActorId() : impl_(ffi::actor_id_nil()) {}

  RustActorId(const RustActorId &other) : impl_(ffi::actor_id_clone(*other.impl_)) {}

  RustActorId &operator=(const RustActorId &other) {
    if (this != &other) {
      impl_ = ffi::actor_id_clone(*other.impl_);
    }
    return *this;
  }

  RustActorId(RustActorId &&other) noexcept = default;
  RustActorId &operator=(RustActorId &&other) noexcept = default;
  ~RustActorId() = default;

  static RustActorId FromBinary(const std::string &binary) {
    RustActorId id;
    rust::Slice<const uint8_t> slice(
        reinterpret_cast<const uint8_t *>(binary.data()), binary.size());
    id.impl_ = ffi::actor_id_from_binary(slice);
    return id;
  }

  static RustActorId FromHex(const std::string &hex) {
    RustActorId id;
    id.impl_ = ffi::actor_id_from_hex(hex);
    return id;
  }

  static const RustActorId &Nil() {
    static RustActorId nil;
    return nil;
  }

  static RustActorId NilFromJob(const RustJobId &job_id) {
    RustActorId id;
    id.impl_ = ffi::actor_id_nil_from_job(job_id.impl());
    return id;
  }

  // Defined after RustTaskId is fully declared
  static RustActorId Of(const RustJobId &job_id,
                        const RustTaskId &parent_task_id,
                        size_t parent_task_counter);

  std::string Binary() const {
    auto vec = ffi::actor_id_to_binary(*impl_);
    return std::string(reinterpret_cast<const char *>(vec.data()), vec.size());
  }

  std::string Hex() const { return std::string(ffi::actor_id_to_hex(*impl_)); }

  bool IsNil() const { return ffi::actor_id_is_nil(*impl_); }

  RustJobId JobId() const {
    RustJobId job_id;
    // Note: This creates a copy through the FFI
    auto job_impl = ffi::actor_id_job_id(*impl_);
    return RustJobId::FromBinary(
        std::string(reinterpret_cast<const char *>(ffi::job_id_to_binary(*job_impl).data()),
                    kRustJobIdSize));
  }

  size_t Hash() const { return ffi::actor_id_hash(*impl_); }

  bool operator==(const RustActorId &other) const {
    return ffi::actor_id_eq(*impl_, *other.impl_);
  }

  bool operator!=(const RustActorId &other) const { return !(*this == other); }

  const ffi::RustActorId &impl() const { return *impl_; }

 private:
  rust::Box<ffi::RustActorId> impl_;
};

/// Drop-in replacement for ray::TaskID backed by Rust implementation.
class RustTaskId {
 public:
  static constexpr size_t Size() { return kRustTaskIdSize; }

  RustTaskId() : impl_(ffi::task_id_nil()) {}

  RustTaskId(const RustTaskId &other) : impl_(ffi::task_id_clone(*other.impl_)) {}

  RustTaskId &operator=(const RustTaskId &other) {
    if (this != &other) {
      impl_ = ffi::task_id_clone(*other.impl_);
    }
    return *this;
  }

  RustTaskId(RustTaskId &&other) noexcept = default;
  RustTaskId &operator=(RustTaskId &&other) noexcept = default;
  ~RustTaskId() = default;

  static RustTaskId FromBinary(const std::string &binary) {
    RustTaskId id;
    rust::Slice<const uint8_t> slice(
        reinterpret_cast<const uint8_t *>(binary.data()), binary.size());
    id.impl_ = ffi::task_id_from_binary(slice);
    return id;
  }

  static RustTaskId FromHex(const std::string &hex) {
    RustTaskId id;
    id.impl_ = ffi::task_id_from_hex(hex);
    return id;
  }

  static RustTaskId FromRandom(const RustJobId &job_id) {
    RustTaskId id;
    id.impl_ = ffi::task_id_from_random(job_id.impl());
    return id;
  }

  static const RustTaskId &Nil() {
    static RustTaskId nil;
    return nil;
  }

  static RustTaskId ForActorCreationTask(const RustActorId &actor_id) {
    RustTaskId id;
    id.impl_ = ffi::task_id_for_actor_creation_task(actor_id.impl());
    return id;
  }

  static RustTaskId ForDriverTask(const RustJobId &job_id) {
    RustTaskId id;
    id.impl_ = ffi::task_id_for_driver_task(job_id.impl());
    return id;
  }

  static RustTaskId ForActorTask(const RustJobId &job_id,
                                 const RustTaskId &parent_task_id,
                                 size_t parent_task_counter,
                                 const RustActorId &actor_id) {
    RustTaskId id;
    id.impl_ = ffi::task_id_for_actor_task(job_id.impl(), parent_task_id.impl(),
                                           parent_task_counter, actor_id.impl());
    return id;
  }

  static RustTaskId ForNormalTask(const RustJobId &job_id,
                                  const RustTaskId &parent_task_id,
                                  size_t parent_task_counter) {
    RustTaskId id;
    id.impl_ = ffi::task_id_for_normal_task(job_id.impl(), parent_task_id.impl(),
                                            parent_task_counter);
    return id;
  }

  static RustTaskId ForExecutionAttempt(const RustTaskId &task_id, uint64_t attempt_number) {
    RustTaskId id;
    id.impl_ = ffi::task_id_for_execution_attempt(task_id.impl(), attempt_number);
    return id;
  }

  std::string Binary() const {
    auto vec = ffi::task_id_to_binary(*impl_);
    return std::string(reinterpret_cast<const char *>(vec.data()), vec.size());
  }

  std::string Hex() const { return std::string(ffi::task_id_to_hex(*impl_)); }

  bool IsNil() const { return ffi::task_id_is_nil(*impl_); }

  bool IsForActorCreationTask() const {
    return ffi::task_id_is_for_actor_creation_task(*impl_);
  }

  RustActorId ActorId() const {
    auto actor_impl = ffi::task_id_actor_id(*impl_);
    auto binary = ffi::actor_id_to_binary(*actor_impl);
    return RustActorId::FromBinary(
        std::string(reinterpret_cast<const char *>(binary.data()), binary.size()));
  }

  RustJobId JobId() const {
    auto job_impl = ffi::task_id_job_id(*impl_);
    auto binary = ffi::job_id_to_binary(*job_impl);
    return RustJobId::FromBinary(
        std::string(reinterpret_cast<const char *>(binary.data()), binary.size()));
  }

  size_t Hash() const { return ffi::task_id_hash(*impl_); }

  bool operator==(const RustTaskId &other) const {
    return ffi::task_id_eq(*impl_, *other.impl_);
  }

  bool operator!=(const RustTaskId &other) const { return !(*this == other); }

  const ffi::RustTaskId &impl() const { return *impl_; }

 private:
  rust::Box<ffi::RustTaskId> impl_;
};

// RustActorId::Of definition (after RustTaskId is fully defined)
inline RustActorId RustActorId::Of(const RustJobId &job_id,
                                   const RustTaskId &parent_task_id,
                                   size_t parent_task_counter) {
  RustActorId id;
  id.impl_ = ffi::actor_id_of(job_id.impl(), parent_task_id.impl(), parent_task_counter);
  return id;
}

/// Drop-in replacement for ray::ObjectID backed by Rust implementation.
class RustObjectId {
 public:
  static constexpr size_t Size() { return kRustObjectIdSize; }

  RustObjectId() : impl_(ffi::object_id_nil()) {}

  RustObjectId(const RustObjectId &other) : impl_(ffi::object_id_clone(*other.impl_)) {}

  RustObjectId &operator=(const RustObjectId &other) {
    if (this != &other) {
      impl_ = ffi::object_id_clone(*other.impl_);
    }
    return *this;
  }

  RustObjectId(RustObjectId &&other) noexcept = default;
  RustObjectId &operator=(RustObjectId &&other) noexcept = default;
  ~RustObjectId() = default;

  static RustObjectId FromBinary(const std::string &binary) {
    RustObjectId id;
    rust::Slice<const uint8_t> slice(
        reinterpret_cast<const uint8_t *>(binary.data()), binary.size());
    id.impl_ = ffi::object_id_from_binary(slice);
    return id;
  }

  static RustObjectId FromHex(const std::string &hex) {
    RustObjectId id;
    id.impl_ = ffi::object_id_from_hex(hex);
    return id;
  }

  static RustObjectId FromIndex(const RustTaskId &task_id, uint32_t index) {
    RustObjectId id;
    id.impl_ = ffi::object_id_from_index(task_id.impl(), index);
    return id;
  }

  static RustObjectId FromRandom() {
    RustObjectId id;
    id.impl_ = ffi::object_id_from_random();
    return id;
  }

  static const RustObjectId &Nil() {
    static RustObjectId nil;
    return nil;
  }

  std::string Binary() const {
    auto vec = ffi::object_id_to_binary(*impl_);
    return std::string(reinterpret_cast<const char *>(vec.data()), vec.size());
  }

  std::string Hex() const { return std::string(ffi::object_id_to_hex(*impl_)); }

  bool IsNil() const { return ffi::object_id_is_nil(*impl_); }

  uint32_t ObjectIndex() const { return ffi::object_id_object_index(*impl_); }

  RustTaskId TaskId() const {
    auto task_impl = ffi::object_id_task_id(*impl_);
    auto binary = ffi::task_id_to_binary(*task_impl);
    return RustTaskId::FromBinary(
        std::string(reinterpret_cast<const char *>(binary.data()), binary.size()));
  }

  size_t Hash() const { return ffi::object_id_hash(*impl_); }

  bool operator==(const RustObjectId &other) const {
    return ffi::object_id_eq(*impl_, *other.impl_);
  }

  bool operator!=(const RustObjectId &other) const { return !(*this == other); }

 private:
  rust::Box<ffi::RustObjectId> impl_;
};

/// Drop-in replacement for ray::UniqueID (also used as WorkerID, NodeID) backed by Rust.
class RustUniqueId {
 public:
  static constexpr size_t Size() { return kRustUniqueIdSize; }

  RustUniqueId() : impl_(ffi::unique_id_nil()) {}

  RustUniqueId(const RustUniqueId &other) : impl_(ffi::unique_id_clone(*other.impl_)) {}

  RustUniqueId &operator=(const RustUniqueId &other) {
    if (this != &other) {
      impl_ = ffi::unique_id_clone(*other.impl_);
    }
    return *this;
  }

  RustUniqueId(RustUniqueId &&other) noexcept = default;
  RustUniqueId &operator=(RustUniqueId &&other) noexcept = default;
  ~RustUniqueId() = default;

  static RustUniqueId FromBinary(const std::string &binary) {
    RustUniqueId id;
    rust::Slice<const uint8_t> slice(
        reinterpret_cast<const uint8_t *>(binary.data()), binary.size());
    id.impl_ = ffi::unique_id_from_binary(slice);
    return id;
  }

  static RustUniqueId FromHex(const std::string &hex) {
    RustUniqueId id;
    id.impl_ = ffi::unique_id_from_hex(hex);
    return id;
  }

  static RustUniqueId FromRandom() {
    RustUniqueId id;
    id.impl_ = ffi::unique_id_from_random();
    return id;
  }

  static const RustUniqueId &Nil() {
    static RustUniqueId nil;
    return nil;
  }

  std::string Binary() const {
    auto vec = ffi::unique_id_to_binary(*impl_);
    return std::string(reinterpret_cast<const char *>(vec.data()), vec.size());
  }

  std::string Hex() const { return std::string(ffi::unique_id_to_hex(*impl_)); }

  bool IsNil() const { return ffi::unique_id_is_nil(*impl_); }

  size_t Hash() const { return ffi::unique_id_hash(*impl_); }

  bool operator==(const RustUniqueId &other) const {
    return ffi::unique_id_eq(*impl_, *other.impl_);
  }

  bool operator!=(const RustUniqueId &other) const { return !(*this == other); }

  const ffi::RustUniqueId &impl() const { return *impl_; }

 private:
  rust::Box<ffi::RustUniqueId> impl_;
};

/// Type aliases for specific ID types that use UniqueId as base
using RustWorkerId = RustUniqueId;
using RustNodeId = RustUniqueId;
using RustFunctionId = RustUniqueId;
using RustActorClassId = RustUniqueId;
using RustConfigId = RustUniqueId;
using RustClusterId = RustUniqueId;

/// Drop-in replacement for ray::PlacementGroupID backed by Rust implementation.
class RustPlacementGroupId {
 public:
  static constexpr size_t Size() { return kRustPlacementGroupIdSize; }

  RustPlacementGroupId() : impl_(ffi::placement_group_id_nil()) {}

  RustPlacementGroupId(const RustPlacementGroupId &other)
      : impl_(ffi::placement_group_id_clone(*other.impl_)) {}

  RustPlacementGroupId &operator=(const RustPlacementGroupId &other) {
    if (this != &other) {
      impl_ = ffi::placement_group_id_clone(*other.impl_);
    }
    return *this;
  }

  RustPlacementGroupId(RustPlacementGroupId &&other) noexcept = default;
  RustPlacementGroupId &operator=(RustPlacementGroupId &&other) noexcept = default;
  ~RustPlacementGroupId() = default;

  static RustPlacementGroupId FromBinary(const std::string &binary) {
    RustPlacementGroupId id;
    rust::Slice<const uint8_t> slice(
        reinterpret_cast<const uint8_t *>(binary.data()), binary.size());
    id.impl_ = ffi::placement_group_id_from_binary(slice);
    return id;
  }

  static RustPlacementGroupId FromHex(const std::string &hex) {
    RustPlacementGroupId id;
    id.impl_ = ffi::placement_group_id_from_hex(hex);
    return id;
  }

  static RustPlacementGroupId Of(const RustJobId &job_id) {
    RustPlacementGroupId id;
    id.impl_ = ffi::placement_group_id_of(job_id.impl());
    return id;
  }

  static const RustPlacementGroupId &Nil() {
    static RustPlacementGroupId nil;
    return nil;
  }

  std::string Binary() const {
    auto vec = ffi::placement_group_id_to_binary(*impl_);
    return std::string(reinterpret_cast<const char *>(vec.data()), vec.size());
  }

  std::string Hex() const { return std::string(ffi::placement_group_id_to_hex(*impl_)); }

  bool IsNil() const { return ffi::placement_group_id_is_nil(*impl_); }

  RustJobId JobId() const {
    auto job_impl = ffi::placement_group_id_job_id(*impl_);
    auto binary = ffi::job_id_to_binary(*job_impl);
    return RustJobId::FromBinary(
        std::string(reinterpret_cast<const char *>(binary.data()), binary.size()));
  }

  size_t Hash() const { return ffi::placement_group_id_hash(*impl_); }

  bool operator==(const RustPlacementGroupId &other) const {
    return ffi::placement_group_id_eq(*impl_, *other.impl_);
  }

  bool operator!=(const RustPlacementGroupId &other) const { return !(*this == other); }

 private:
  rust::Box<ffi::RustPlacementGroupId> impl_;
};

/// Drop-in replacement for ray::LeaseID backed by Rust implementation.
class RustLeaseId {
 public:
  static constexpr size_t Size() { return kRustLeaseIdSize; }

  RustLeaseId() : impl_(ffi::lease_id_nil()) {}

  RustLeaseId(const RustLeaseId &other) : impl_(ffi::lease_id_clone(*other.impl_)) {}

  RustLeaseId &operator=(const RustLeaseId &other) {
    if (this != &other) {
      impl_ = ffi::lease_id_clone(*other.impl_);
    }
    return *this;
  }

  RustLeaseId(RustLeaseId &&other) noexcept = default;
  RustLeaseId &operator=(RustLeaseId &&other) noexcept = default;
  ~RustLeaseId() = default;

  static RustLeaseId FromBinary(const std::string &binary) {
    RustLeaseId id;
    rust::Slice<const uint8_t> slice(
        reinterpret_cast<const uint8_t *>(binary.data()), binary.size());
    id.impl_ = ffi::lease_id_from_binary(slice);
    return id;
  }

  static RustLeaseId FromHex(const std::string &hex) {
    RustLeaseId id;
    id.impl_ = ffi::lease_id_from_hex(hex);
    return id;
  }

  static RustLeaseId FromWorker(const RustUniqueId &worker_id, uint32_t counter) {
    RustLeaseId id;
    id.impl_ = ffi::lease_id_from_worker(worker_id.impl(), counter);
    return id;
  }

  static RustLeaseId FromRandom() {
    RustLeaseId id;
    id.impl_ = ffi::lease_id_from_random();
    return id;
  }

  static const RustLeaseId &Nil() {
    static RustLeaseId nil;
    return nil;
  }

  std::string Binary() const {
    auto vec = ffi::lease_id_to_binary(*impl_);
    return std::string(reinterpret_cast<const char *>(vec.data()), vec.size());
  }

  std::string Hex() const { return std::string(ffi::lease_id_to_hex(*impl_)); }

  bool IsNil() const { return ffi::lease_id_is_nil(*impl_); }

  RustUniqueId WorkerId() const {
    auto worker_impl = ffi::lease_id_worker_id(*impl_);
    auto binary = ffi::unique_id_to_binary(*worker_impl);
    return RustUniqueId::FromBinary(
        std::string(reinterpret_cast<const char *>(binary.data()), binary.size()));
  }

  size_t Hash() const { return ffi::lease_id_hash(*impl_); }

  bool operator==(const RustLeaseId &other) const {
    return ffi::lease_id_eq(*impl_, *other.impl_);
  }

  bool operator!=(const RustLeaseId &other) const { return !(*this == other); }

 private:
  rust::Box<ffi::RustLeaseId> impl_;
};

}  // namespace ray

// std::hash specializations
namespace std {

template <>
struct hash<ray::RustJobId> {
  size_t operator()(const ray::RustJobId &id) const { return id.Hash(); }
};

template <>
struct hash<ray::RustActorId> {
  size_t operator()(const ray::RustActorId &id) const { return id.Hash(); }
};

template <>
struct hash<ray::RustTaskId> {
  size_t operator()(const ray::RustTaskId &id) const { return id.Hash(); }
};

template <>
struct hash<ray::RustObjectId> {
  size_t operator()(const ray::RustObjectId &id) const { return id.Hash(); }
};

template <>
struct hash<ray::RustUniqueId> {
  size_t operator()(const ray::RustUniqueId &id) const { return id.Hash(); }
};

template <>
struct hash<ray::RustPlacementGroupId> {
  size_t operator()(const ray::RustPlacementGroupId &id) const { return id.Hash(); }
};

template <>
struct hash<ray::RustLeaseId> {
  size_t operator()(const ray::RustLeaseId &id) const { return id.Hash(); }
};

}  // namespace std

// Copyright 2017 The Ray Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <cstdint>
#include <memory>
#include <string>

#include "rust/cxx.h"

// Include the generated CXX bridge header
// This is generated by cxxbridge from id.rs
#include "src/ray/ffi/id_bridge_gen.h"

namespace ray {

/// ID sizes matching C++ implementation
constexpr size_t kRustJobIdSize = 4;
constexpr size_t kRustActorIdSize = 16;
constexpr size_t kRustTaskIdSize = 24;
constexpr size_t kRustObjectIdSize = 28;
constexpr size_t kRustUniqueIdSize = 28;

/// Drop-in replacement for ray::JobID backed by Rust implementation.
class RustJobId {
 public:
  static constexpr size_t Size() { return kRustJobIdSize; }

  RustJobId() : impl_(ffi::job_id_nil()) {}

  RustJobId(const RustJobId &other) : impl_(ffi::job_id_clone(*other.impl_)) {}

  RustJobId &operator=(const RustJobId &other) {
    if (this != &other) {
      impl_ = ffi::job_id_clone(*other.impl_);
    }
    return *this;
  }

  RustJobId(RustJobId &&other) noexcept = default;
  RustJobId &operator=(RustJobId &&other) noexcept = default;
  ~RustJobId() = default;

  static RustJobId FromInt(uint32_t value) {
    RustJobId id;
    id.impl_ = ffi::job_id_from_int(value);
    return id;
  }

  static RustJobId FromBinary(const std::string &binary) {
    RustJobId id;
    rust::Slice<const uint8_t> slice(
        reinterpret_cast<const uint8_t *>(binary.data()), binary.size());
    id.impl_ = ffi::job_id_from_binary(slice);
    return id;
  }

  static RustJobId FromHex(const std::string &hex) {
    RustJobId id;
    id.impl_ = ffi::job_id_from_hex(hex);
    return id;
  }

  static const RustJobId &Nil() {
    static RustJobId nil;
    return nil;
  }

  uint32_t ToInt() const { return ffi::job_id_to_int(*impl_); }

  std::string Binary() const {
    auto vec = ffi::job_id_to_binary(*impl_);
    return std::string(reinterpret_cast<const char *>(vec.data()), vec.size());
  }

  std::string Hex() const { return std::string(ffi::job_id_to_hex(*impl_)); }

  bool IsNil() const { return ffi::job_id_is_nil(*impl_); }

  size_t Hash() const { return ffi::job_id_hash(*impl_); }

  bool operator==(const RustJobId &other) const {
    return ffi::job_id_eq(*impl_, *other.impl_);
  }

  bool operator!=(const RustJobId &other) const { return !(*this == other); }

  const ffi::RustJobId &impl() const { return *impl_; }

 private:
  rust::Box<ffi::RustJobId> impl_;
};

/// Drop-in replacement for ray::ActorID backed by Rust implementation.
class RustActorId {
 public:
  static constexpr size_t Size() { return kRustActorIdSize; }

  RustActorId() : impl_(ffi::actor_id_nil()) {}

  RustActorId(const RustActorId &other) : impl_(ffi::actor_id_clone(*other.impl_)) {}

  RustActorId &operator=(const RustActorId &other) {
    if (this != &other) {
      impl_ = ffi::actor_id_clone(*other.impl_);
    }
    return *this;
  }

  RustActorId(RustActorId &&other) noexcept = default;
  RustActorId &operator=(RustActorId &&other) noexcept = default;
  ~RustActorId() = default;

  static RustActorId FromBinary(const std::string &binary) {
    RustActorId id;
    rust::Slice<const uint8_t> slice(
        reinterpret_cast<const uint8_t *>(binary.data()), binary.size());
    id.impl_ = ffi::actor_id_from_binary(slice);
    return id;
  }

  static RustActorId FromHex(const std::string &hex) {
    RustActorId id;
    id.impl_ = ffi::actor_id_from_hex(hex);
    return id;
  }

  static const RustActorId &Nil() {
    static RustActorId nil;
    return nil;
  }

  static RustActorId NilFromJob(const RustJobId &job_id) {
    RustActorId id;
    id.impl_ = ffi::actor_id_nil_from_job(job_id.impl());
    return id;
  }

  std::string Binary() const {
    auto vec = ffi::actor_id_to_binary(*impl_);
    return std::string(reinterpret_cast<const char *>(vec.data()), vec.size());
  }

  std::string Hex() const { return std::string(ffi::actor_id_to_hex(*impl_)); }

  bool IsNil() const { return ffi::actor_id_is_nil(*impl_); }

  RustJobId JobId() const {
    RustJobId job_id;
    // Note: This creates a copy through the FFI
    auto job_impl = ffi::actor_id_job_id(*impl_);
    return RustJobId::FromBinary(
        std::string(reinterpret_cast<const char *>(ffi::job_id_to_binary(*job_impl).data()),
                    kRustJobIdSize));
  }

  size_t Hash() const { return ffi::actor_id_hash(*impl_); }

  bool operator==(const RustActorId &other) const {
    return ffi::actor_id_eq(*impl_, *other.impl_);
  }

  bool operator!=(const RustActorId &other) const { return !(*this == other); }

  const ffi::RustActorId &impl() const { return *impl_; }

 private:
  rust::Box<ffi::RustActorId> impl_;
};

/// Drop-in replacement for ray::TaskID backed by Rust implementation.
class RustTaskId {
 public:
  static constexpr size_t Size() { return kRustTaskIdSize; }

  RustTaskId() : impl_(ffi::task_id_nil()) {}

  RustTaskId(const RustTaskId &other) : impl_(ffi::task_id_clone(*other.impl_)) {}

  RustTaskId &operator=(const RustTaskId &other) {
    if (this != &other) {
      impl_ = ffi::task_id_clone(*other.impl_);
    }
    return *this;
  }

  RustTaskId(RustTaskId &&other) noexcept = default;
  RustTaskId &operator=(RustTaskId &&other) noexcept = default;
  ~RustTaskId() = default;

  static RustTaskId FromBinary(const std::string &binary) {
    RustTaskId id;
    rust::Slice<const uint8_t> slice(
        reinterpret_cast<const uint8_t *>(binary.data()), binary.size());
    id.impl_ = ffi::task_id_from_binary(slice);
    return id;
  }

  static RustTaskId FromHex(const std::string &hex) {
    RustTaskId id;
    id.impl_ = ffi::task_id_from_hex(hex);
    return id;
  }

  static RustTaskId FromRandom(const RustJobId &job_id) {
    RustTaskId id;
    id.impl_ = ffi::task_id_from_random(job_id.impl());
    return id;
  }

  static const RustTaskId &Nil() {
    static RustTaskId nil;
    return nil;
  }

  static RustTaskId ForActorCreationTask(const RustActorId &actor_id) {
    RustTaskId id;
    id.impl_ = ffi::task_id_for_actor_creation_task(actor_id.impl());
    return id;
  }

  std::string Binary() const {
    auto vec = ffi::task_id_to_binary(*impl_);
    return std::string(reinterpret_cast<const char *>(vec.data()), vec.size());
  }

  std::string Hex() const { return std::string(ffi::task_id_to_hex(*impl_)); }

  bool IsNil() const { return ffi::task_id_is_nil(*impl_); }

  bool IsForActorCreationTask() const {
    return ffi::task_id_is_for_actor_creation_task(*impl_);
  }

  RustActorId ActorId() const {
    auto actor_impl = ffi::task_id_actor_id(*impl_);
    auto binary = ffi::actor_id_to_binary(*actor_impl);
    return RustActorId::FromBinary(
        std::string(reinterpret_cast<const char *>(binary.data()), binary.size()));
  }

  RustJobId JobId() const {
    auto job_impl = ffi::task_id_job_id(*impl_);
    auto binary = ffi::job_id_to_binary(*job_impl);
    return RustJobId::FromBinary(
        std::string(reinterpret_cast<const char *>(binary.data()), binary.size()));
  }

  size_t Hash() const { return ffi::task_id_hash(*impl_); }

  bool operator==(const RustTaskId &other) const {
    return ffi::task_id_eq(*impl_, *other.impl_);
  }

  bool operator!=(const RustTaskId &other) const { return !(*this == other); }

  const ffi::RustTaskId &impl() const { return *impl_; }

 private:
  rust::Box<ffi::RustTaskId> impl_;
};

/// Drop-in replacement for ray::ObjectID backed by Rust implementation.
class RustObjectId {
 public:
  static constexpr size_t Size() { return kRustObjectIdSize; }

  RustObjectId() : impl_(ffi::object_id_nil()) {}

  RustObjectId(const RustObjectId &other) : impl_(ffi::object_id_clone(*other.impl_)) {}

  RustObjectId &operator=(const RustObjectId &other) {
    if (this != &other) {
      impl_ = ffi::object_id_clone(*other.impl_);
    }
    return *this;
  }

  RustObjectId(RustObjectId &&other) noexcept = default;
  RustObjectId &operator=(RustObjectId &&other) noexcept = default;
  ~RustObjectId() = default;

  static RustObjectId FromBinary(const std::string &binary) {
    RustObjectId id;
    rust::Slice<const uint8_t> slice(
        reinterpret_cast<const uint8_t *>(binary.data()), binary.size());
    id.impl_ = ffi::object_id_from_binary(slice);
    return id;
  }

  static RustObjectId FromHex(const std::string &hex) {
    RustObjectId id;
    id.impl_ = ffi::object_id_from_hex(hex);
    return id;
  }

  static RustObjectId FromIndex(const RustTaskId &task_id, uint32_t index) {
    RustObjectId id;
    id.impl_ = ffi::object_id_from_index(task_id.impl(), index);
    return id;
  }

  static RustObjectId FromRandom() {
    RustObjectId id;
    id.impl_ = ffi::object_id_from_random();
    return id;
  }

  static const RustObjectId &Nil() {
    static RustObjectId nil;
    return nil;
  }

  std::string Binary() const {
    auto vec = ffi::object_id_to_binary(*impl_);
    return std::string(reinterpret_cast<const char *>(vec.data()), vec.size());
  }

  std::string Hex() const { return std::string(ffi::object_id_to_hex(*impl_)); }

  bool IsNil() const { return ffi::object_id_is_nil(*impl_); }

  uint32_t ObjectIndex() const { return ffi::object_id_object_index(*impl_); }

  RustTaskId TaskId() const {
    auto task_impl = ffi::object_id_task_id(*impl_);
    auto binary = ffi::task_id_to_binary(*task_impl);
    return RustTaskId::FromBinary(
        std::string(reinterpret_cast<const char *>(binary.data()), binary.size()));
  }

  size_t Hash() const { return ffi::object_id_hash(*impl_); }

  bool operator==(const RustObjectId &other) const {
    return ffi::object_id_eq(*impl_, *other.impl_);
  }

  bool operator!=(const RustObjectId &other) const { return !(*this == other); }

 private:
  rust::Box<ffi::RustObjectId> impl_;
};

}  // namespace ray

// std::hash specializations
namespace std {

template <>
struct hash<ray::RustJobId> {
  size_t operator()(const ray::RustJobId &id) const { return id.Hash(); }
};

template <>
struct hash<ray::RustActorId> {
  size_t operator()(const ray::RustActorId &id) const { return id.Hash(); }
};

template <>
struct hash<ray::RustTaskId> {
  size_t operator()(const ray::RustTaskId &id) const { return id.Hash(); }
};

template <>
struct hash<ray::RustObjectId> {
  size_t operator()(const ray::RustObjectId &id) const { return id.Hash(); }
};

}  // namespace std
